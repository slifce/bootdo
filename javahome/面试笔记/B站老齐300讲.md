001:架构
架构基于场景，架构没有对错，只有是否合适

002：Mysql集群模式和应用场景
集群模式
读写分离
分库分表（分片）：范围法【服务器节点数据分配不均，可能前面的满，第二个占用一半，第三个是空的】、Hash法取模【扩展极大难度】
主流架构：数据分片+集群+读写分离三者的综合使用

003：数据的垂直分表
通过将重要的字段单独剥离出一张小表，让每一页能够容纳更多的行，进而缩小数据扫描的范围，达到提高执行效率的目的
剥离的场景：单表数据超千万，字段超过20个，含有Varchar,CLOB,BLOB等字段

004：多级缓存
1.web应用的客户端缓存（CND内容网络分发）
2.应用层的静态资源缓存（nginx静态资源缓存）
3.服务层的多级缓存（redis数据缓存）

005：外包
java中级18K~27K（24K）
java高级25K~35K（30K）

006：todo

007:水平分表主键严禁使用自增主键
分布式环境下
自增id，不可取
UUID，频繁的索引重排，不可取
雪花算法，41bit时间戳+10bit机器ID+12bit序列，可能出现时钟回拨的情况，通常不用考虑

008：布隆过滤器
缓存穿透攻击：用户恶意的在短时间内大量查询不存在的数据，导致大量请求被送达数据库进行查询，当请求数量超过数据库的负载上限时，系统就会出现高延迟甚至瘫痪
初始化一个长度为N的二进制数组，经过K次Hash运行进行长度N取模运，落点位置改为1,
布隆过滤器认为：判断一个编号是否存在，通过布隆过滤器的多个hash运算以后的位置都是1，才可能存在；有一个为0，就一定不存在。
都是1也可能是不存在的，优化方案：1.增加二进制的位数，使得hash之后的数据更加分散；2.增加Hash次数。代价就是CPU需要进行更多的计算
场景：如果放进布隆过滤器的编号被删除了怎么办？可能某一个二进制位被多个hash引用，因此布隆过滤器无法直接删除
解决方法1：定时异步重建布隆过滤器
解决方法2：计数Bloom Filter，每一个二进制位再多一个位进行计数操作
生产环境使用布隆过滤器：
1.应用启动初始化布隆过滤器
2.用户请求编号进行布隆过滤器判断
3.存在则读取redis,如果redis不存在，则读数据库再载入redis
4.布隆过滤器不存在编号，返回数据不存在信息

009：京东禁止ip直连:会暴露ip和端口，如果服务器更换会导致重新部署上线，很笨重。
方法1采用DNS采用域名解析服务，将域名mywebname以及真实ip配置在DNS服务器上，当tomcat请求的时候首先由DNS解析域名返回真实ip然后再请求到相应服务，
缺点，无法实现故障转移。
引入方法2，注册中心，通过心跳包进行注册，间隔一段时间发送告诉注册中心自己还存活，请求过来也会由注册中心在注册服务列表进行指定的负载均衡策略返回ip

010：CAP定理:一致性，可用性，分区容错性（分布式系统在遇到某个节点或网络分区故障的时候，仍然能够对外提供一致性或可用性的服务）

011：负载均衡:硬件负载均衡器F5 ，软件负载均衡nginx
负载均衡策略有默认的轮询，权重，ip hash,需要额外安装的url hash（访问的文件路径） 和fair（谁空闲谁处理）

012：阿里规则-禁用外键约束：
优点，数据库层面实现，保护数据的完整性和一致性，级联操作方便
缺点，级联删除这里数据库的一系列逻辑导致不可控，数据耦合度大，数据迁移困难

201：慎用select ... for update
用到索引可用时使用行锁
索引不可用时使用表锁
解决办法1：强制走索引
explain select * from employee force index(dname) where dname = 'SALES' for update;
解决办法2：增加limit关键字，减少扫描范围
explain select * from employee where dname = 'SALES' LIMIT 0,10 for update;
发散问题：update语句会锁表吗？不会！因为update语句会将其转变成为主键索引
explain update employee set ename = 'KING' where dname = 'SALES';
执行计划中的select_type为UPDATE,table为employee,type为index,possible_key为dname,key为PRIMARY
最终建议：很多人工作中会习惯采用select ... for update实现资源提前锁定，或者实现分布式锁，这里一定要关注是否能否是用到索引，
一不留神就可能锁表，建议是改为分布式锁如Redis setNX、Zookeeper等专物专用。

分布式事务方案：
2PC和3PC
事务协调者
1.事务预处理阶段
2.询问是否可以提交阶段（2PC无）
3.提交阶段
超时自动提交，避免锁被长期占有导致系统崩溃

TCC（try confirm cancel）
需要对表加状态字段，然后有中间值记录

seata分布式事务
TC:事务协调者
TM:事务管理器
RM:资源管理器

延迟取消订单：
1.定时任务
2.redis6的过期通知
3.RocketMQ的延迟队列，死信队列

开闭原则：对扩展开放，对修改关闭
单一职能原则：一个类做一件事情
里氏替换原则：子类重写父类的方法，不能逻辑不一致，或者新建数据自己的方法（储蓄卡、信用卡通过继承抽象类银行卡，银行卡实现加减钱，各个子类实现取款或者体现）
迪米特法则：最小知道原则，减少耦合
接口隔离原则：拆分方法到接口中，大接口变成小接口，需要用的时候实现不同的接口
依赖倒置原则：重点是将接口作为入参传递，具体业务场景可以传入不同的实现类

事件复杂度：
hash算法如redis.get  O(1)
链表遍历O(N)
B+树，二分法 O(log n)
双重forO(N^2)

zk实现分布式锁（临时顺序节点+watch）（临时节点唯一性+重试）
1.zk在持久节点parentLock，当客户端client1想要获取锁，则需要创建临时顺序节点node1，并且判断自己创建的临时顺序节点node1是否顺序最靠前。
如果是则获取锁成功，执行同步代码块。
2.在此时客户端client2（理解为不同的进程）也想要获取锁，同样在持久节点parentLock下面创建临时顺序节点node2，
并且判断自己创建的临时顺序节点node2是否顺序最靠前，发现不是，client2向前排序仅比它靠前的节点注册Watcher，
用来监听--临时节点1是否存在。这意味着client2抢锁失败。
3.如果监听到node1被删除，则解锁成功，client2可以拿到锁来执行同步代码块。
