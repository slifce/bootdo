**非公平锁**
【优势：比公平锁效率高，比从队列中拿线程修改状态涉及到线程状态的切换(耗时)】
【劣势：可能造成队列中的线程饥饿，长时间拿不到锁】
同时多个线程争抢资源，只会有一个线程可以拿到锁，其余线程进行等待队列排队【线程状态未挂起】，
当持有锁的线程释放锁以后，回去查看有没有新的线程【线程状态运行】来要获取锁，
如果有就直接让该线程获取到锁
如果没有，就从等待队列里面去拿


**ThreadLocal**
使用场景1：全局存储用户信息
使用场景2：解决线程安全问题 每个线程将数据库连接的connection存进ThreadLocalMap中，如果再次连接数据库的时候，先从当前线程中获取，没有的话创建
解决内存泄漏：使用完以后手动调用remove()方法就会删除ThreadLocal中的Map


**String的不可变性**
类被final修饰，核心char[] value也是final修饰，构造方法不能修改
存在常量池，以供复用
常用作HashMap的key,可以较好的去检索相应的value
不可变的，多线程环境下是安全的.


**创建线程池**
阿里规范指出，不能使用Executors进行创建，而是需要通过ThreadExecutorPool进行创建，并指定
核心线程数coreSize,
最大线程数maxNunSize,
线程执行完任务以后存活时间time，
存活时间单位timeUnit,
工作队列workQueue,
创建线程的工厂threadFactory(非必填)，
拒绝策略rejectHandle(非必填)
指定有界的工作队列如ArrayBlockingQueue(10),防止使用默认（LinkedBlockingQueue）的导致创建线程数过多或者队列过长引发OOM


**CAS操作缺点[内存位置（V）、预期原值（A）和新值(B)]**
cas操作是java是实现乐观锁的一种方式，避免加锁提高存取效率，就是假设通常情况下该共享变量没有被修改，
通过内存值V和预期值A进行比较，如果没有变化就将内存值修改为新值B,否则处理器不做处理
1.ABA问题：解决办法是加一个版本号V1,V2,V3,对比内存之和预期值的同时进行版本号对比
2.自旋时间过长：根据场景判断并发度大小选择是否使用CAS
3.范围不能灵活控制：多个值同时进行CAS操作很难处理。解决办法是将需要同时进行CAS操作的值放到同一个类中进行管理