1.spring是如何通过三级缓存解决循环依赖的（智弘沟通）
一级缓存（singletonObjects）它用来存放经过完整Bean生命周期过程的单例Bean对象
二级缓存（earlySingletonObjects）存储提前曝光的属性未填充的bean，，它用来保存哪些没有经过完整Bean生命周期的单例Bean对象，用来保证不完整的bean也是单例
三级缓存（singletonFactories）存储生成bean的工厂，存在则放入二级缓存并在三级缓存删除，其他需要会先从二级缓存中拿到，保证是同一个bean,场景A依赖B,C;B也依赖A，C也依赖A

2.springboot的启动流程

3.redis怎么实现分布式锁以及优缺点

4.redisson实现分布式锁

5.aqs原理及countDownLatch原理
AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。
AQS使用CAS对该同步状态进行原子操作实现对其值的修改。
以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。
此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。
当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。
这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。
等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

6.索引失效场景

7.mysql如何实现可重复读

8.工作流有了解吗(activity和flowable)