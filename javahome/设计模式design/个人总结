---设计模式
创建型模式
1.工厂模式
基于原有的if-else的类型进行分支冗余处理，使用工厂模式以后，工厂类负责创建业务实例，通过抽象类定义接口，各业务类型类实现接口完成各自业务。后续新增加的业务类型可以在工厂类中添加。
此设计模式避免的高耦合。
满足单一职能原则，每⼀个业务逻辑实现都在所属⾃⼰的类中完成；
满⾜开闭原则，⽆需更改使⽤调⽤⽅就可以在程序中引⼊新的产品类型。

2.抽象工厂模式
适配接口下多实现类，Proxy抽象工厂+工厂实现。
ICacheAdapter ，定义了适配接⼝，分别包装两个集群中差异化的接⼝名称。 EGMCacheAdapter 、 IIRCacheAdapter
JDKProxy 、 JDKInvocationHandler ，是代理类的定义和实现，这部分也就是抽象⼯⼚的另外⼀种实现⽅式。
通过这样的⽅式可以很好的把原有操作Redis的⽅法进⾏代理操作，通过控制不同的⼊参对象，控制缓存的使⽤。

3.建造者模式
⼀些基本物料不会变，⽽其组合经常变化的时候 ，就可以选择这样的设计模式来构建代码。
定义装修包接⼝中的方法返回类型为接口类型，可以多次调用其方法为建造类提供不同的组合。
Builder ，建造者类具体的各种组装由此类实现。
DecorationPackageMenu ，是 IMenu 接⼝的实现类，主要是承载建造过程中的填充器。相当于这是⼀套承载物料和创建者中间衔接的内容。

4.原型模式
通过克隆⽅式创建复杂对象
①两个 append() ，对各项题⽬的添加，有点像我们在建造者模式中使⽤的⽅式，添加装修物料。
②clone() ，这⾥的核⼼操作就是对对象的复制，这⾥的复制不只是包括了本身，同时对两个集合也做了复制。只有这样的拷⻉才能确保在操作克隆对象的时候不影响原对象。
③乱序操作，在 list 集合中有⼀个⽅法， Collections.shuffle ，可以将原有集合的顺序打乱，输出⼀个新的顺序。在这⾥我们使⽤此⽅法对题⽬进⾏乱序操作。

5.单例模式
①静态类使用，定义一个static的变量。
②懒汉模式【线程安全get方法加synchronized】+【线程不安全】 (构造私有，防止new生成对象。成员变量私有。get为public static提供对象)
③双重锁校验双（锁的⽅式是⽅法级锁的优化，减少了部分获取实例的耗时。同时这种⽅式也满⾜了懒加载）
④枚举单例(线程安全、⾃由串⾏化、单⼀实例)
注意懒加载场景，如果生成对象条件苛刻，出要在出发一定条件后生成，则需要使用懒加载。线程安全上需要按需选择。


结构型模式
1.适配器模式
接⼝适配、MQ适配。之所以不只是模拟接⼝适配，因为很多时候⼤家都很常⻅了，所以把适配的思想换⼀下到MQ消息体上，增加⼤家多设计模式的认知。
先是做MQ适配，接收各种各样的MQ消息。当业务发展的很快，需要对下单⽤户⾸单才给奖励，在这样的场景下再增加对接⼝的适配操作。

2.桥接模式
与上⾯的ifelse实现⽅式相⽐，这⾥的调⽤⽅式变得整洁、⼲净、易使⽤； 
new WxPay(newPayFaceMode()) 、 new ZfbPay(new PayFingerprintMode())
外部的使⽤接⼝的⽤户不需要关⼼具体的实现，只按需选择使⽤即可。
⽬前以上优化主要针对桥接模式的使⽤进⾏᯿构 if 逻辑部分，关于调⽤部分可以使⽤ 抽象⼯⼚ 或策略模式 配合map结构，将服务配置化。
因为这⾥主要展示 桥接模式 ，所以就不在额外多加代码，避免喧宾夺主。
