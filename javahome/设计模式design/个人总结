---设计模式
1.工厂模式
基于原有的if-else的类型进行分支冗余处理，使用工厂模式以后，工厂类负责创建业务实例，通过抽象类定义接口，各业务类型类实现接口完成各自业务。后续新增加的业务类型可以在工厂类中添加。
此设计模式避免的高耦合。
满足单一职能原则，每⼀个业务逻辑实现都在所属⾃⼰的类中完成；
满⾜开闭原则，⽆需更改使⽤调⽤⽅就可以在程序中引⼊新的产品类型。

2.抽象工厂模式
适配接口下多实现类，Proxy抽象工厂+工厂实现。
ICacheAdapter ，定义了适配接⼝，分别包装两个集群中差异化的接⼝名称。 EGMCacheAdapter 、 IIRCacheAdapter
JDKProxy 、 JDKInvocationHandler ，是代理类的定义和实现，这部分也就是抽象⼯⼚的另外⼀种实现⽅式。
通过这样的⽅式可以很好的把原有操作Redis的⽅法进⾏代理操作，通过控制不同的⼊参对象，控制缓存的使⽤。

3.建造者模式
⼀些基本物料不会变，⽽其组合经常变化的时候 ，就可以选择这样的设计模式来构建代码。
定义装修包接⼝中的方法返回类型为接口类型，可以多次调用其方法为建造类提供不同的组合。
Builder ，建造者类具体的各种组装由此类实现。
DecorationPackageMenu ，是 IMenu 接⼝的实现类，主要是承载建造过程中的填充器。相当于这是⼀套承载物料和创建者中间衔接的内容。

4.原型模式
通过克隆⽅式创建复杂对象
①两个 append() ，对各项题⽬的添加，有点像我们在建造者模式中使⽤的⽅式，添加装修物料。
②clone() ，这⾥的核⼼操作就是对对象的复制，这⾥的复制不只是包括了本身，同时对两个集合也做了复制。只有这样的拷⻉才能确保在操作克隆对象的时候不影响原对象。
③乱序操作，在 list 集合中有⼀个⽅法， Collections.shuffle ，可以将原有集合的顺序打乱，输出⼀个新的顺序。在这⾥我们使⽤此⽅法对题⽬进⾏乱序操作。
