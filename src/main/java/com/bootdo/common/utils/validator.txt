package code.validator.base;

public class CommonValidatorHelper {
    private static final CommonValidatorHelper COMMON_VALIDATOR_HELPER
            = new CommonValidatorHelper();

    private CommonValidatorHelper() {
    }

    /**
     * 获取实例
     *
     * @return 实例对象
     */
    public static CommonValidatorHelper getInstance() {
        return COMMON_VALIDATOR_HELPER;
    }

    /**
     * 是否存在审视名单校验
     *
     * @param dynamicObject 当前动态对象
     * @return 错误提示
     */
    public String isExistsValidate(DynamicObject dynamicObject) {
        // 执行业务逻辑
        return "存在审视名单校验";
    }

    /**
     * 是否启动校验
     *
     * @param dynamicObject 当前动态对象
     * @return 错误提示
     */
    public String isStartValidate(DynamicObject dynamicObject) {
        // 执行业务逻辑
        return "启动校验";
    }

}

package code.validator.base;

public class DynamicObject {
}


package code.validator.base;

import org.apache.commons.lang3.StringUtils;

/**
 * 通用校验器接口
 *
 * @since 2020/11/27
 */
public interface ValidatorBase {
    /**
     * 校验，返回错误信息
     *
     * @param dynamicObject 动态对象
     * @return 错误信息
     */
    Object validate(DynamicObject dynamicObject);

    /**
     * 是否继续校验
     *
     * @return true 继续后续校验
     * false 不再继续后续校验
     */
    boolean continueValidate();

    abstract class AbstractErrorMsgSignValidator implements ValidatorBase {
        /**
         * 错误信息
         */
        protected String errorMsg = null;

        /**
         * 真正的校验方法，转换一下返回类型
         *
         * @param dynamicObject 申请单实体
         * @return 错误信息
         */
        protected abstract String realValidate(DynamicObject dynamicObject);

        /**
         * 校验，返回错误信息
         *
         * @param dynamicObject 申请实体
         * @return 错误信息
         */
        @Override
        public Object validate(DynamicObject dynamicObject) {
            return realValidate(dynamicObject);
        }

        /**
         * 是否继续校验
         *
         * @return true 继续后续校验
         * false 不再继续后续校验
         */
        @Override
        public boolean continueValidate() {
            return StringUtils.isEmpty(errorMsg);
        }
    }
}

package code.validator.base;

import code.validator.rule.IsExistsValidator;
import code.validator.rule.IsStartValidator;

public class ValidatorFactory {
    /**
     * 导入校验器holder
     *
     * @param dynamicObject 数据
     * @return 校验器holder
     */
    public static ValidatorHolder getImportValidatorHolder(DynamicObject dynamicObject) {
        // 校验全部
        ValidatorHolder holder = new ValidatorHolder(dynamicObject, true);
        // 原合同校验
        return getCommonValidatorHolder(holder);
    }

    /**
     * 手动新增校验器holder
     *
     * @param dynamicObject 数据
     * @return 校验器holder
     */
    public static ValidatorHolder getManualValidatorHolder(DynamicObject dynamicObject) {
        // 只抛出第一条不符合校验的提示
        ValidatorHolder holder = new ValidatorHolder(dynamicObject);
        // 原校验
        return getCommonValidatorHolder(holder);
    }

    private static ValidatorHolder getCommonValidatorHolder(ValidatorHolder holder) {
        // 是否已存在与审视名单校验
        holder.addValidator(new IsExistsValidator())
                // 是否已启动校验
                .addValidator(new IsStartValidator());
        return holder;
    }

}


package code.validator.base;

import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

public class ValidatorHolder {

    /**
     * 是否走完全部校验
     */
    private boolean validateAll;

    /**
     * 校验器集合，用于子类使用
     */
    private LinkedList<ValidatorBase> validators;

    /**
     * 申请实体
     */
    private DynamicObject signObj;

    public ValidatorHolder(DynamicObject signObj) {
        this.signObj = signObj;
        this.validateAll = false;
        validators = new LinkedList<>();
    }

    public ValidatorHolder(DynamicObject signObj, boolean validateAll) {
        this.signObj = signObj;
        this.validateAll = validateAll;
        validators = new LinkedList<>();
    }

    /**
     * 添加校验器
     *
     * @param validator 校验器
     * @return 当前对象
     */
    public ValidatorHolder addValidator(ValidatorBase validator) {
        validators.add(validator);
        return this;
    }

    /**
     * 移除校验器
     *
     * @param validator 校验器签证
     */
    public void removeValidator(ValidatorBase validator) {
        validators.remove(validator);
    }

    /**
     * 校验方法
     *
     * @return 校验结果
     */
    public Object startValidate() {
        return validateAll ? validateAll() : validateFirst();
    }

    /**
     * 开始校验，逐个开始校验
     * 如果不需要继续校验，则返回当前结果
     * 如果需要继续校验，则获取下一个校验器并继续校验
     *
     * @return 校验结果
     */
    private Object validateFirst() {
        for (ValidatorBase validator : validators) {
            Object validateResult = validator.validate(signObj);
            if (!validator.continueValidate()) {
                return validateResult;
            }
        }
        return null;
    }

    /**
     * 走完全部校验，获取校验结果
     *
     * @return 多条校验结果
     */
    private String validateAll() {
        StringBuffer errMsg = new StringBuffer();
        List<Object> allValidateError = getAllValidateError();
        allValidateError.forEach(validateResult -> {
            if (!StringUtils.isEmpty((String) validateResult)) {
                errMsg.append(validateResult);
                if (!String.class.cast(validateResult).endsWith(";")) {
                    errMsg.append(";");
                }
            }
        });
        return StringUtils.isEmpty(errMsg.toString()) ? null : errMsg.toString();
    }

    /**
     * 获取所有校验结果，不会因为单个校验器校验不通过而返回
     *
     * @return 错误信息集合，所有校验器的错误信息
     */
    private List<Object> getAllValidateError() {
        List<Object> errorList = new ArrayList<>(10);
        for (ValidatorBase validator : validators) {
            Object validateResult = validator.validate(signObj);
            if (!Objects.isNull(validateResult)) {
                errorList.add(validateResult);
            }
        }
        return errorList;
    }
}



package code.validator.rule;

import code.validator.base.DynamicObject;
import code.validator.base.CommonValidatorHelper;
import code.validator.base.ValidatorBase;

public class IsExistsValidator extends ValidatorBase.AbstractErrorMsgSignValidator {
    @Override
    protected String realValidate(DynamicObject dynamicObject) {
        errorMsg = CommonValidatorHelper.getInstance().isExistsValidate(dynamicObject);
        return errorMsg;
    }
}



package code.validator.rule;

import code.validator.base.DynamicObject;
import code.validator.base.CommonValidatorHelper;
import code.validator.base.ValidatorBase;

public class IsStartValidator extends ValidatorBase.AbstractErrorMsgSignValidator {
    @Override
    protected String realValidate(DynamicObject dynamicObject) {
        errorMsg = CommonValidatorHelper.getInstance().isStartValidate(dynamicObject);
        return errorMsg;
    }
}

package code;

import code.validator.base.DynamicObject;
import code.validator.base.ValidatorFactory;
import code.validator.base.ValidatorHolder;
import org.apache.commons.lang3.tuple.ImmutablePair;

public class Test {

    public static void main(String[] args) {
        DynamicObject dynamicObject = new DynamicObject();
        ImmutablePair<Boolean, String> booleanStringImmutablePairSingle = validatorSingle(dynamicObject);
        System.out.println(booleanStringImmutablePairSingle.getRight());
        ImmutablePair<Boolean, String> booleanStringImmutablePairAll = validatorAll(dynamicObject);
        System.out.println(booleanStringImmutablePairAll.getRight());
    }

    public static ImmutablePair<Boolean, String> validatorSingle(DynamicObject dynamicObject){
        ImmutablePair<Boolean, String> result = ImmutablePair.of(Boolean.TRUE, null);
        // 错误信息，校验通过时为空
        String errorMsg;
        // 根据前置业务类型进行不同校验器的组合
        ValidatorHolder importValidatorHolder = ValidatorFactory.getManualValidatorHolder(dynamicObject);
        Object error = importValidatorHolder.startValidate();
        if (error != null) {
            errorMsg = String.class.cast(error);
            result = ImmutablePair.of(Boolean.FALSE, errorMsg);
        }
        return result;
    }

    public static ImmutablePair<Boolean, String> validatorAll(DynamicObject dynamicObject){
        ImmutablePair<Boolean, String> result = ImmutablePair.of(Boolean.TRUE, null);
        // 错误信息，校验通过时为空
        String errorMsg;
        // 根据前置业务类型进行不同校验器的组合
        ValidatorHolder importValidatorHolder = ValidatorFactory.getImportValidatorHolder(new DynamicObject());
        Object error = importValidatorHolder.startValidate();
        if (error != null) {
            errorMsg = String.class.cast(error);
            result = ImmutablePair.of(Boolean.FALSE, errorMsg);
        }
        return result;
    }
}


---设计模式
1.工厂模式
基于原有的if-else的类型进行分支冗余处理，使用工厂模式以后，工厂类负责创建业务实例，通过抽象类定义接口，各业务类型类实现接口完成各自业务。后续新增加的业务类型可以在工厂类中添加。
此设计模式避免的高耦合。
满足单一职能原则，每⼀个业务逻辑实现都在所属⾃⼰的类中完成；
满⾜开闭原则，⽆需更改使⽤调⽤⽅就可以在程序中引⼊新的产品类型。

2.抽象工厂模式
适配接口下多实现类，Proxy抽象工厂+工厂实现。
ICacheAdapter ，定义了适配接⼝，分别包装两个集群中差异化的接⼝名称。 EGMCacheAdapter 、 IIRCacheAdapter
JDKProxy 、 JDKInvocationHandler ，是代理类的定义和实现，这部分也就是抽象⼯⼚的另外⼀种实现⽅式。
通过这样的⽅式可以很好的把原有操作Redis的⽅法进⾏代理操作，通过控制不同的⼊参对象，控制缓存的使⽤。
