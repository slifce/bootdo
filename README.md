# bootdo
后台管理
自学自测自省
不断更新提升
dev
测试修改master

Nacos
什么是 Nacos？
Nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。

Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。

Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。

官网：https://nacos.io
源码：https://github.com/alibaba/nacos

全景图：



架构及概念


服务 (Service)
服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service.

服务注册中心 (Service Registry)
服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。

服务元数据 (Service Metadata)
服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据

服务提供方 (Service Provider)
是指提供可复用和可调用服务的应用方

服务消费方 (Service Consumer)
是指会发起对某个服务调用的应用方

配置 (Configuration)
在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。

配置管理 (Configuration Management)
在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。

名字服务 (Naming Service)
提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -> Endpoints Info, Distributed Lock Name -> Lock Owner/Status Info, DNS Domain Name -> IP List, 服务发现和 DNS 就是名字服务的2大场景。

配置服务 (Configuration Service)
在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。

Nacos vs Spring Cloud
相对于 Spring Cloud Eureka 来说，Nacos 更强大。

Nacos = Spring Cloud Eureka + Spring Cloud Config

Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。

通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。
通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。


https://www.cnblogs.com/coder-qi/p/11072500.html
spring源码与调试


https://blog.csdn.net/weixin_41624318/article/details/108712319
idea版本和gradle版本对应关系

第4讲
强引用:最为常见的一种,只要还有强引用指向一个对象,就能表示对象还活着
软引用:相对于强引用的弱化,会在OOM之前去清理软引用指向的对象.通常应用场景为一些缓存数据
弱引用:仅仅提供一种访问在弱引用状态下对象的途径.
幻象引用(虚引用):可用作监控对象的创建和销毁.

第5讲
不可变String;(直接赋值字符串,放入字符串常量池;new String字符串,对象放入堆中)
可变StringBuffer(线程安全);StringBuilder(线程不安全)
基于字符串String的不可变延伸
~通过String和相关类,考察基本的线程安全设计与实现,各种基础变编程实践
~考察JVM对象缓存机制的理解以及如何良好的使用
~考察JVM优化Java代码的一些技巧
~String相关类的演进,比如Java9中实现的巨大改变[StringBuffer.StringBuilder](char->byte)
应用场景：
[A]在字符串内容弄不经常发生改变的业务场景优先使用String类。例如:常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，
避免使用String和String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费控件且执行效率地下（新建对象、回收对象花费大量时间）。
[B]在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer,例如XML解析、HTTP参数解析与封装。
[C]在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder,例如SQL语句拼装，JSON封装等。


第6讲
动态代理原理
https://docs.oracle.com/javase/tutorial/reflect/index.html
代理模式:通过代理静默的解决一些业务无关的问题,比如远程、安全、事务、日志、资源关闭....让应用开发者可以只关心他的业务
静态代理:事先写好代理类,可以手工编写,也可以用工具生成.缺点是每个业务对象类都要对应一个代理类,非常不灵活.
动态代理:运行时自动生成代理对象。缺点是生成代理代理对象和调用方法都需要额外时间。
JDK动态代理:基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。
cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。
Java反射机制的常见应用：动态代理（AOP、RPC)、提倡第三方开发者扩展能力（Servlet容器、JDBC连接）、第三方组件创建对象（DI）......
反思点：
[A]考察你对反射机制的了解和掌握程度。
[B]动态代理解决了什么问题，在你的业务系统中的应用场景是什么？
[C]JDK动态代理在设计和实现上与cglib等方式有什么不同，进而如何取舍？


第7讲
int和Integer有什么区别？
JDK1.5引入了自动装箱与自动拆箱功能，Java可根据上下文，实现int/Integer/,double/Double,
boolean/Boolean等基本类型与相应对象之间的自动转换，为开发过程带来极大便利。
数据类型范围和缓存范围的区别
Integer的缓存范围-128~127
Integer的数据范围-2^31~2^31-1
注意事项：
[A]基本数据类型均具有取值范围，在大数*大数的时候，有可能出现越界的情况。
[B]基本类型转换时，使用声明的方式。例：int l = 1234567890 * 24 *365;结果值一定不会是你所期望的那个值，
因为1234567890 * 24已经超过int的范围，如果修改为long l = 1234567890 * 24 *365;就正常了。
[C]慎用基本类型处理货币存储。如果采用double常会来带差距，常采用BigDecimal、整型（如果要精确表示分，可以将值扩大100倍转化为整型）解决该问题
[D]优先使用基本类型。原则上，建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合。
[E]如果有现成安全的计算需要，建议考虑使用类型AtomicInteger、AutomicLong这样的现成安全类。部分比较宽的基本数据类型，比如float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值。

第8讲
对比Vector、ArrayList、LinkedList有何区别？
Java集合底层基本上就是基于数组或者链表实现的，数组的地址连续性决定了其随机存取速度较快，但是涉及到扩容则比较耗时，
而链表则不存在扩容的性能消耗，但随机访问需要遍历地址因此相对数组要慢，所以判断一个集合的特点可以先判断是基于数组还是链表。
数组和链表的增删查需要考虑头尾部情况，则会出现是否有性能偏差。
问题：
你需要实现一个云计算任务调度系统，希望可以保证VIP客户的任务被优先处理，你可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景多数是什么数据结构呢？
利用PriorityBlockingQueue或者Disruptor可以实现基于任务优先级为调度策略的执行调度系统。

第9讲
对比Hashtable、HashMap、TreeMap有什么不同？
Java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），
我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。
另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：
[A]各种并容器，比如ConcurrentHashMap、CopyOnWriteArrayList。
[B]各种线程安全队列（Queue/Deque），如ArrayBlockingQueue、SynchronousQueue。
[C]各种有序容器的线程安全版本等。

第10讲
如何保证集合是线程安全的 ConcurrentHashMap如何实现搞笑的线程安全？
自旋锁和偏向锁
自旋锁是cas的一种应用方式。并发包中的原子类是典型的应用。
偏向锁是获取锁的优化。在ReentrantLock中用于实现已获取完锁的线程重入问题。即侧重是低竞争场景的优化，去掉可能不必要的同步。
jdk1.7 put加锁
通过分段加锁segment，一个hashmap里有若干个segment，每个segment里有若干个桶，桶里存放K-V形式进行加锁，
然后再哈希，计算得到给元素要添加到的桶，然后遍历桶中的链表，替换或新增节点到桶中。
size分段计算两次，两次结果相同则返回，否则对锁以段加锁重新计算

jdk1.8 put CAS加锁
1.8中不依赖与segment加锁，segment数量与桶数量一致；
首先判断容器是否为空，为空则进行初始化利用volatile的sizeCtl作为互斥手段，如果发现竞争性的初始化，
就暂停在那里，等待条件恢复，否则利用CAS设置排他标志（U.compareAndSwapInt(this,SIZECTL, src, -1)）;否则重试
对key hash计算得到该key存放的桶位置，判断该桶是否为空，为空则利用CAS设置新节点否则使用synchronize加锁，遍历桶中数据，
替换或新增加到桶中，最后判断是够需要转为红黑树，转换之前判断是否需要扩容
size利用LongAdd累加计算

第11讲
Java提供了哪些IO方式？NIO如何实现多路复用？
44f4700f28c0303e

第12讲
Java有几种文件拷贝方式？哪一种最高效？

第13讲
谈谈接口抽象类有什么区别？
接口和抽象类是Java面向对象设计的两个基础机制。
接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。
接口，不能实例化；不能包含任何非常量成员，任何field都是隐含着public static final 的意义；
同时，没有实例化
1287628769087043584:{"isSuccess":true

自旋锁是尝试获取锁的线程不会立即阻塞，采用循环的方式去获取锁，好处是减少了上下文切换，缺点是消耗CPU

自旋锁：竞争锁的失败的线程，并不会真是的在操作系统层面挂起等待，而是JVM会让线程做几个空循环（基于预测在不就的将来就能获得），
在经过若干次循环后，如果可以获得锁，那么进去临界区，如果还不能获得锁，才会做真实的将线程在操作系统层面进行挂起。

适用场景：自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。
如果锁的竞争激烈，或者持有锁的线程需要长时间占用CPU做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成CPU的浪费。
第23讲
请介绍类加载过程，什么是双亲委派模型？
一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里有详细的定义。
首先是加载阶段（Loading），他是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），
这里的数据源可能是各种各样的形态，如jar文件、class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFileError。

加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。

第二阶段是链接（Linking）,这是核心的步骤，简单说是把原始的类定义信息平滑地转化入JVM运行的过程中。这里可进一步细分为三个步骤：
①验证（Verification），这是虚拟机安全的重要保障，JVM需要核验字节信息是否符合Java虚拟机规范的，
否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息危害JVM的运行，验证阶段有可能
触发更多的class的加载。

②准备（Preparation），创建类或者接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”
和下面的显示初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令。

③解析（Resolution），在这一步将常量池中的符号引用替换为直接引用。在Java虚拟机规范中，详细介绍了
类、接口、方法和字段等各个方面的解析。

最后是初始化阶段（initialzation），这一步真正执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。

双亲委派模型就是当类加载器（Class-Loader）试图加载某个类型的时候，除非附加在其找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。



第24讲 有哪些方法可以在运行时动态生成一个Java类？
字节码操纵技术，除了动态代理，还可以应用在什么地方？

①各种Mock框架
②ORM框架
③IOC容器
④部分Profiler工具
⑤生成形式化代码的工具

GC新生代对象晋升到老年代情况总结
对象优先在Eden分配，且新生代对象晋升到老年代有多重情况
总结：
①Eden区满时，进行Minor GC。
当Eden和一个Survivor区中依然存活的对象无法放入到Survivor中，则通过分配担保机制提前转移到老年代中。
②若对象体积太大，新生代无法容纳这个对象。
-XX:PretenureSizeThreshold即对象的大小大于此值，就会绕过新生代没直接在老年代分配，此参数只对Serial及ParNew两款收集器有效。
③长期存活的对象将进入老年代。
虚拟机对每个对象都定义了一个对象年龄（Age）计数器，当年龄增加到一定的临界值时，就会晋升到老年代中，改临界值由参数：-XX：MaxTenuringThreshold来设置
如果对象在Eden出生并在第一次发生MinorGC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor中，并且设Age=1；以后每次经历一次Minor GC,该对象还存活的话Age=Age+1.
④动态对象年龄判定
虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄(设年龄为age)的对象的所有大小只和超过Survivor空间的一半，
年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。

第29讲 Java内存模型中的happen-before是什么？
可从四个维度去裂解JMM
1.从JVM运行时视角来看，JVM内存可分为JVM栈、本地方法栈、PC计数器、方法区、堆；其中前三个是线程私有的，后两者是所有线程共有的

2.从JVM内存功能视角来看，JVM可分为堆内存、非堆内存与其他。其中堆内存对应于上述的堆区，非堆内存对应于上述的JVM栈，本地方法栈，PC计数器，方法区；其他则对应于直接内存

3.从线程运行视角来看，JVM可以分为主内存和线程工作内存。Java内存模型规定了所有的变量都存储在主内存中；每个线程的工作内存保存了被该线程使用到的变量，这些变量是主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存总进行，而不能直接读写主内存中的变量

4从垃圾回收视角来看，JVM中的堆区=新生代+老年代。新生代主要用于存放新创建的对象与存活时间长小的对象，新生代=E+S1+S2;老年代则用于存放存活时间长的对象

JMM可以从两个方面理解：
一是抽象内存结构，JMM把内存结构抽象成主内存和线程本地内存两种，在计算时，从主内存中加载数据，在本地内存计算，然后再刷新到主内存，但这种模型有明显的一致性问题
二是JMM可以理解为一组保住内存可见性及成正确性的规范，因为这种模型存在明显的一致性问题，同时由于java编译器指令重排序优化和cpu乱序执行优化的存在，使问题变得更加复杂，
所以JMM基于内存屏障提供了类似sa if serial以及happens before的保障。从使用者的角度理解，JMM平衡了JVM工程师以及CPU工程师在性能上的需求和java程序员在简单性上的渴望，所以JMM在保证了正确性的同事会最大限度的放宽对指令重排和乱序执行的限制。
对于java程序员,JMM提供了如volatile和synchronized这样的顶层机制为程序员提供简单的编程模型。


2020 Dubbo面试题大全(https://blog.csdn.net/baidu_37366055/article/details/104892209)

基础知识
为什么要使用Dubbo?
随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系（SOA）,也因此衍生出
了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封
装的服务框架、就这样为分布式系统的服务治理框架就出现了，Dubbo也就这样产生了。

Dubbo是什么？
Dubbo是一款高性能、轻量级的开源RPC框架，提供服务自动注册、自动发现等高效服务治理方案，可以和Spring框架无缝集成。

Dubbo的使用场景有哪些？
· 透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。
· 软负载均衡及容错机制：可在内网替代F5等硬件负载均衡器，降低成本，减少单点
· 服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除
  服务提供者。

架构设计
Dubbo核心组件有哪些？
· Provider:暴露服务的服务提供方
· Consumer:调用远程服务消费方
· Registry:服务注册与发现注册中心
· Monitor:监控中心的访问调用统计
· Container:服务运行容器

Dubbo服务注册与发现的流程？
服务容器Container负责启动，加载，运行服务提供者。
服务提供者Provider在启动时，向注册中心注册自己提供的服务。
服务消费者Consumer在启动时，向注册中心订阅自己所需要的服务。
注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长链接推送变更数据给消费者。
服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。

分布式框架
Dubbo类似的分布式框架还有哪些还有哪些？
比较著名的就是Spring Cloud。

Dubbo和Spring Cloud有什么关系？
Dubbo是SOA时代的产物，他的关注点主要在于服务的调用，流量分发、流量监控和熔断。而Spring Cloud诞生于微服务架构时代，
考虑的是微服务治理的方方面面，另外由于依托了Spring、Spring Boot的优势之上，两个框架在开始目标就不一致，Dubbo定位服务
治理、Spring Cloud是打造一个生态。




spring ioc 是一种思想，即将容器中的所有bean交给spring进行管理，控制权转移的这个过程

百万级别或以上的数据如何删除
关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件，
所以当我们对数据的增加，修改，删除都会产生额外的对索引文件的操作，
这些操作需要消耗额外的IO，会降低增删改的执行效率，所以，我们再删除数据库百万级别数据的时候，
查询Mysql官方手册得知删除数据的速度和创建索引数量是成正比的。
1.所以我们想要删除百万数据的时候，可以先删除索引
2.然后删除其中无用的数据
3.删除完成后重新创建索引，创建索引也很快
4.与之前的直接删除绝对是要快速很多，更别说万一删除中断，一切删除会回滚

=======
mysql 命令行
mysql -u root -p bootdo

enter password:xxx

show databases;

show tables;

show variables like '%log_bin%';

show variavles like '%datadir%';

explain select * from sys_user where dept_id = 6;

master update

dev commit


12312313
